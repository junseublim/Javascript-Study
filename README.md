# Javascript-Study
“모던 자바스크립트 입문” 서적을 사용한 자바스크립트 학습

## Chapter 1 : 자바스크립트 개요


### 자바스크립트의 특징

1. 인터프리터 언어입니다. 인터프리터 언어는 프로그램을 한 줄마다 기계어로 번역해서 실행하는 언어입니다. 인터프리터 언어는 프로그램을 바로 실행할 수 있고 동작을 확인해 가면서 프로그램을 개발할 수 있다는 장점이 있습니다. 그러나 컴파일 언어보다 처리 속도가 느립니다.

2. 동적 프로토타입 기반 객체 지향 언어입니다. 변수 타입이 정해져 있지 않고 프로그램이 실행되는 도중에 변수의 데이터 타입이 변경될 수 있습니다.

3. 함수가 일급 객체입니다. 함수에 함수를 인수로 넘길 수 있습니다. 이를 활용해서 고차원 함수를 구현하고 함수형 프로그래밍이 가능합니다.

4. 함수가 클로저를 정의합니다. 자바스크립트의 함수는 클로저를 정의합니다. 클로저는 변수를 은닉하거나 영속성을 보장하는 등 다양한 기능을 구현할 수 있습니다. 

## Chapter 3 : 변수와 값

### 변수

- 변수 선언으 var문으로 할 수 있으며, 만약 var를 생략시 전역변수로 선언하게 됩니다.
- 처음 변수를 선언하면 변수안에는 undefined 라는 값이 들어갑니다.
```js
var a; //undefined
```
- 호이스팅: 변수 선언은 프로그램 첫머리로 끌어 올려집니다.
    - 다만, 변선 선언과 동시에 대입하는 값은 끌어올려지지 않습니다.
    - 또한 var 문을 이용하여 같은 이름을 가진 변수를 여러개 선언하더라도 문제가 발생하지 않습니다.

### 데이터 값

- 데이터 타입은 원시 타입과 객체 타입으로 나눌 수 있다.
    - 원시 타입: 숫자, 문자열, 논리값, 특수한 값(undefined, null), 심벌
    - 객체 타입: 여러개의 변수가 모여서 만들어진 복합 데이터 타입. 객체 안에 저장된 값은 바꿀 수 있다. 객체는 참조 타입이므로 객체 타입의 값을 변수에 대입하면 변수에는 그 객체에 대한 참조가 할당된다.
- 숫자: 정수, 부동소수점 타입이 따로 없고 모두 64비트 부동소수점으로 표현한다.
- 특수한 값: 
    1. undefined: 정의되지 않음을 뜻한다.
        - 값을 아직 할당하지 않은 변수
        - 없는 객체의 프로퍼티를 읽으려고 시도했을 때
        - 없는 배열의 요소를 읽으려고 했을 때
        - 아무것도 반환하지 않는 함수의 반환값
        - 함수를 호출했을 때 전달받지 못한 인수의 값
    2. null: 아무것도 없음을 표현한 리터럴. 주로 무언가를 검색했지만 찾지 못했을 때 아무것도 없음을 전달하기 위한 값으로 사용.

### ECMAScript 6부터 추가된 데이터 타입

#### 심벌

심벌은 자기 자신을 제외한 그 어떤값과도 다른 유일무이한 값입니다.

**심벌의 생성** 

심벌은 Symbol()을 사용해서 생성한다. 호출할 때마다 새로운 값을 생성. 심벌은 서로 항상 값이 다르다.

```js 
var sym1 = Symbol();
var sym2 = Symbol();
console.log(sym1 == sym2) // false
```

심벌 생성자 안에 인수를 전달하면 생성된 심벌의 설명을 덧붙일 수 있습니다. 이 설명은 toString() 메서드로 확인할 수 있습니다.

```js
var HEART = Symbol("하트");
console.log(HEART.toString()); // Symbol(하트)
```

**심벌과 문자열 연결하기**

Symbol.for()를 활용하면 문자열과 연결된 심벌을 생성할 수 있습니다. 그러면 전역 레지스트리에 심벌이 만들어집니다. 이 기능을 활용해서 코드 어느 부분에서도 같은 심벌을 공유할 수 있습니다. 심벌과 연결된 문자열은 Symbol.keyFor()로 구할 수 있습니다.

```js
var sym1 = Symbol.for("club");
var sym2 = Symbol.for("club");
console.log(sym1 == sym2); //true
```
```js
var sym1 = Symbol.for("club");
var sym2 = Symbol("club");
console.log(Symbol.keyFor(sym1)); // club
console.log(Symbol.keyFor(sym2)); // undefined
```

## Chapter 4 : 객체

### 객체

객체란 원시 타입을 제외한 모든 값이다. 객체는 이름과 값을 한 쌍으로 묶은 데이터를 여러 개 모은 것. 객체의 각 데이터를 **프로퍼티**라 부르며 프로퍼티의 이름 부분을 **키**라고 부른다.

#### 객체 리터럴로 객체 생성

{...} 로 객체를 생성하는 것을 객체 리터럴이라고 한다. 프로퍼티 이름으로는 모든 식별자와 문자열 리터럴을 사용할 수 있다.
```js
var card = {suit: '하트', rank : 'A'};
var card = {'suit': '하트', 'rank' : 'A'}; // 문자열로도 이름을 설정할 수 있다.
```
프러퍼티 값을 읽거나 쓸때는 마침표 또는 대괄호 안에 문자열로 접근한다.
```js
card.suit // -> 하트
card['rank'] // -> A
```
객체에 없는 프로퍼티를 읽으려고 시도하면 undefined를 반환한다.

#### 프러퍼티 추가, 삭제

없는 프로퍼티 이름에 값을 대이바면 새로운 프러퍼티가 추가된다.
delete 연산을 사용하여 프로퍼티를 삭제할 수 있다.
```js
card.value = 14;
delete card.value;
```

#### in 연산자로 프로퍼티 확인

in 연산자로 객체에 특정 프로퍼티가 있는지 확인 가능하다. 포함할 경우 true, 아닐 경우 false를 반환.
```js
console.log('suit' in card) // true;
```

in 연산자가 조사하는 대상은 그 객체가 가진 프로퍼티와 그 **객체가 상속받은 모든 프로퍼티**이다.

### 메서드

객체의 프로퍼티 중에서 함수 객체의 참조를 값으로 담고있는 프로퍼티를 메서드라고 부른다. 메서드는 일반적으로 속한 객체의 내부 데이터 상태를 바꾸는 용도로 사용한다.

### 객체의 생성자

자바스크립트는 클래스가 없다. 대신 생성자라고 하는 함수로 객체를 생성할 수 있다.

```js
function Card(suit, rank) {
    this.suit = suit;
    this.rank = rank;
}
//생성자로 객체를 생성할 때는 new 연산자를 사용한다.
var card = new Card("하트", "A");
```

### 배열

자바스크립트의 배열은 객체 타입이므로 배열을 변수에 대입하면 배열의 참조가 변수에 저장된디ㅏ.

배열 리터럴 요소의 값을 생략하면 그 요소는 생성되지 않는다. undefined로 표시되지만 실제로는 없다.

배열에는 모든 타입의 값이 올 수 있다.

length 프로퍼티: 배열 요소의 개수를 뜻하지 않는 경우가 있다.(희소 배열)
- 현재의 배열 요소 개수보다 작고 0보다 큰 정수 값을 대입하면 배열 길이가 줄어듭니다. 즉, 그 배열 길이를 넘는 인덱스 번호에 할당된 배열 요소는 삭제된다.
- 현재의 배열 길이보다 큰 정수값을 대입하면 새로운 요소가 추가되지 않고 length 프로퍼티만 바뀐다.

Array 생성자로도 생성할 수 있다. 
- 인수로 배열의 값들을 넣어주면 된다.
- 이때 생성자의 인수가 한개고 그 값이 양의 정수면 의미가 달라진다. 인수는 배열 길이를 뜻하므로 배열이 그 길이만큼 생성된다.
- 만약 인수가 한개고 음수이면 오류가 발생한다.

자바스크립트에서 배열은 Array 객체이며 객체로 배열의 기능을 가상으로 흉내낸 것이다. Array 객체는 배열의 인덱스를 문자열로 변환해서 그것을 프로퍼티로 이용한다. 그러나 C나 Java처럼 연속된 공간에 차례대로 배치되어 있지 않기 때문에 속도가 느리다. 이를 해결하고자 ECMAScript 6부터는 TypedArray가 추가되었다. 이는 다른 언어의 배열과 마찬가지로 연속된 공간에 차례대로 배치된다.

#### 배열 요소의 추가와 삭제

- 없는 배열 요소에 값을 대입하면 새로운 요소가 추간된다.
- push 메서드를 이용해서 끝에 추가 할 수 있다.
- delete 연산자를 사용하면 특정 배열 요소를 삭제할 수 있다. **단, 배열의 요소를 삭제해도 배열의 length 프로퍼티 값은 바뀌지 않고, 삭제한 요소만 사라진다.**


### 희소 배열
배열에 요소를 추가하거나 제거하면 인덱스가 0부터 시작되지 않는 배열이 만들어진다. 이러한 배열을 희소 배열이라고 부른다. 이때는 length 프로퍼티의 값과 실제 개수와의 차이가 생긴다.

- 배열 요소가 있는지 확인하기 위해서는 객체의 프로퍼티가 있는지 확인하는 방법과 마찬가지로 for/in문이나 hasOwnProprty method를 사용해서 확인할 수 있다.
```js
for (var i in a) console.log(i);
a.hasOwnProperty("3");
```

## Chapter 5: 연산자

1. 산술연산자
    1. 나머지 연산의 결과는 부동소수점이다. (Ex. 7%2 = 3.5)
    2. 나머지 연산의 피연산자는 부동소수점이다. 
    3. \+ 연산자의 피연산자 중 하나가 문자열이면 다른 피연산자도 문자열로 연산한다
    4. 계산 할 수 없는 경우 NaN으로 평가된다. True는 1, false,null은 0으로 평가한다. Undefined는 Nan이다.
2. 문자열 제어하기
    1. 문자열 연결: + 연산자로 연결 가능
        1. 피연산자가 객체 등 문자열로 변환할 수 있는 객체라면 다른 피연산자의 타입을 문자열로 바꾼 다음 연결.
        2. 그렇지 않다면 두개를 숫자 또는 Nan으로 바꾼 후 더한다.
3. 문자열 객체 String: 문자열 처리를 도와줌.
    1. new String(“문자열”) 로 생성한다.
        1. 그러나 문자열에서 프로퍼티를 사용하려고 하면 자동으로 객체로 변환해주기 때문에 할 필요없다.
4. 문자열은 불변이다.
    1. 따라서 배열처럼 읽을 수는 있지만, 대입할 수는 없다.
5. 동일 연산자 ==
    1. Undefined, null은 같다.
    2. 한쪽이 숫자고, 한쪽이 문자열이면 문자열을 숫자로 변환해서 비교.
    3. 한쪽이 논리값이면, 1,0으로 변환해서 비굑
    4. 한쪽 이 객체, 다른 쪽이 숫자 또는 문자열이면 객체를 toString이나 valueOf 메서도를 사용해서 원시타입으로 변환한 다음 비교
    5. 앞의 규칙에서 벗어나면 false
6. 일치 연산자 === 
    1. 피연산자를 변환하지 않고 엄격하게 비교. 
    2. NaN은 NaN과도 같지 않다.
7. 논리곱, 논리합 연산자
    1. 마지막으로 평가한 피연산자값을 반환한다.
    ```js
    return A && B // A가 true이면 B를 반환, 아니면 A를 반환.
    ```
8. 문자열로 명시적 변환
    1. String 함수를 사용할 때 new를 붙이지 않고 사용하면 String 객체가 아닌 문자열을 반환한다.
    ```js
    String(26) = “26”
    ```
9. 숫자로 명시적 변환
    ```js
    var s = "1";
    s-0;
    +s;
    parseInt(“123”); //해석해서 변환(16진법, 2진법 등) 불가능할경우 NaN
    Number(“123”);
    ```
10. 논리값으로 명시적 변환
    ```js
    !!x
    Boolean(x)
    ```

## Chapter 6: 웹브라우저에서의 입출력

### 대화상자
- window.alert : 경고 메세지를 표시
- window.prompt : 입력 대화상자를 표시
- window.confirm : 확인과 취소 버튼이 있다. 확인 클릭시 true, 취소 클릭시 false 반환.

window. 부분을 생략하고 호출할 수 있다.

### console

Console 객체의 주요 메서드
1. console.dir : 객체의 대화형 목록을 출력
2. console.error : 오류 메시지 출력
3. console.info : 메시지 타입 로그를 출력
4. console.log : 일반 로그를 출력
5. console.time : 처리 시간 측정용 타이머를 시작
6. console.timeEnd : 처리 사건 측정용 타이머를 정지시키고 타이머를 시작한 후에 흐른 시간을 밀리초 단위로 출력
7. console.trace : 스택 트레이스를 출력
8. console.warn : 경고 메시지를 출력


### 이벤트 처리기

웹 브라우저에서 동작하는 프로그램은 기본적으로 이벤트 주도형 프로그램이다. 이벤트란 사용자가 버튼을 클릭하는 행위처럼 단말기와 애플리케이션이 처리할 수 있는 동작이나 사건을 뜻한다. 이벤트 주도형 프로그램이란 이벤트가 발생할 때까지 기다렸다가 이벤트가 발생했을 때 미리 등록한 작업을 수행하는 프로그램을 말한다.

함수를 이벤트 처리기로 등록하는 방법은 3가지가 있다.

### HTML 요소의 속성으로 등록하기

```html
<input type="button" value="click" onclick="displayTime()">
```

html 요소에서 속성으로 직접 이벤트 처리기를 추가하는 방법이다. 이벤트 처리기 속성에는 이벤트가 발생했을 때 실행할 자바스크립트 문장을 문자열로 만들어 대입한다. 속성에 문장을 여러 개 작성하고자 할 때는 문장과 문장을 세미콜론으로 구분한다. 

이벤트 처리기 속성을 사용하는 방식은 HTML 코드와 자바스크립트 코드가 뒤섞이는 단점이 있다. 따라서 다른 방법들이 더 선호된다.

### DOM에서 가져온 HTML 요소에 이벤트 처리기 지정하기

DOM은 자바스크립트에서 HTML 요소를 조작할 수 있게 하는 인터페이스이다. 

#### DOM 객체

DOM에서는 HTML 문서나 HTML 요소를 가리키는 객체로 자바스크립트를 사용하여 문서를 조작한다. DOM의 주요 객체는 다음과 같이 분류할 수 있다.
- window: Window 객체, 웹 브라우저 윈도우 하나 혹은 탭 하나를 가리킨다.
- document: Document 객체, HTML 문서 전체를 가리킨다. HTML 문서에서 HTML 요소 객체를 가져오거나 HTML 요소를 새로 만드는 등 HTML 문서 전반에 걸친 기능을 제공한다.
- 요소 객체: HTML 문서의 요소를 가리키는 객체

DOM을 사용해서 이벤트 처리기 등록하는 방법은 다음과 같다.

1. window.onload를 사용해서 HTML 문서를 다 읽어 들인다.
2. document.getElementById 메서드를 사용하여 특정 id 속성 값을 가진 HTML 요소의 요소 객체를 가져온다.
3. 요소 객체의 이벤트 처리기 프로퍼티에 이벤트 처리기로 동작할 함수를 등록한다.

```js
function displayTime() {
    var d = new Date();
    console.log(d.toLocaleString());
}
window.onload = function() {
    var button = document.getElementById('button');
    button.onclick = displayTime;
}
```

이벤트 처리기 제거하기 위해서는 null을 등록하면 된다.


## Chapter 8 : 함수

### 함수를 정의하는 방법

함수를 정의하는 방법은 네 가지이다.

1. 함수 선언문
```js
function square(x) {return x*x}
```

2. 함수 리터럴로 정의하는 방법
```js
var square = function (x) {return x*x}
```

3. Function 생성자로 정의하는 방법
```js
var square = new Function("x", "return x*x");
```


3. 화살표 함수 표현식으로 정의하는 방법 (ECMAScript 6)
```js
var square = x => x*x;
```

함수 선언문(1번)으로 정의된 함수는 호이스팅 된다. 다른 방법들은 호이스팅되지 않는다.

### 중첩 함수

중첩 함수란 함수 내부에 선언된 함수를 의미한다. 

- 외부 함수의 최상위 레벨에만 중첩 함수를 작성할 수 있다. if 문, while 문 등의 문장 블록안에는 중첩 함수를 작성할 수 없다.

- 중첩 함수의 참조는 그 중첩 함수를 들러싼 외부 함수의 지역 변수에 저장되므로 외부 함수의 바깥에서는 읽거나 쓸 수 없다. 

- 또한 중첩 함수는 자신을 둘러싼 외부 함수의 인수와 지역 변수에 접근 할 수 있다. 이는 클로저의 핵심적인 구성 요소가 된다.

### 함수 호출하기

함수를 호출하는 방법은 4가지이다.

1. 함수의 참조가 저장된 변수 뒤에 그룹 연산자인 ()를 붙여서 호출

2. 메서드 호출: 객체의 프로퍼티에 저장된 값이 함수 타입일 경우 ()를 붙여서 호출.

3. 생성자 호출: 함수 또는 메서드를 호출할 때 함수의 참조를 저장한 변수 앞에 new 키워드를 추가하면 함수가 생성자로 동작한다.

4. call, apply를 사용한 간접 호출

### 즉시 실행 함수

즉시 실행 함수를 정의하는 방법은 두가지가 있다.
```js
(function() {...})();
```
```js
(function() {...}());
```
즉시 실행 함수는 전역 유효 범위를 오염시키지 않는 이름 공간을 생성할 때 사용한다.


### 함수의 인수

함수에서 정의식에 작성된 인자 개수보다 인수가 적게 전달되면 생략된 인수는 undefined가 된다. 논리합 연산자를 이용해서 생략시에 사용할 초깃값을 설정할 수 있다.

```js
function multiply(a, b) {
    b = b || 1; //b가 undefined일 경우, 1을 반환
    return a*b;
}
```

#### 가변 길이 인수 목록(Arguments 객체)

함수에서는 지역 변수로 arguments 변수가 존재한다. arguments는 Arguments 객체이다. 함수에 인수를 넘기면 순서대로 arguments에 유사 배열 객체로 저장된다.

Arguments 객체는 프로퍼티로 length와 callee를 갖고 있다. 
- arguments.length : 인수 개수
- arguments.callee : 현재 실행되고 있는 함수의 참조

arguments.callee를 사용하면 이름이 없는 익명함수도 재귀호출을 할 수 있다.

### 프로그램의 평가와 실행 과정

자바스크립트 엔진은 실행 가능한 코드를 만나면 그 코드를 평가해서 실행 문맥으로 만든다. 이 실행 가능한 코드의 유형은 3가지이다. 
- 전역 코드 : 전역 객체 Window 아래에 정의된 함수
- 함수 코드 : 함수를 의미
- eval 코드 : eval 함수

실행 문맥을 초기화하는 과정이 다르기 때문에 코드의 유형을 분류한다. 

실행 문맥은 실행 가능한 코드가 실제로 실행되고 관리되는 영역으로 실행에 필요한 모든 정보를 컴포넌트 여러 개가 나누어 관리하도록 만들어져 있다.

그중에서 가장 중요한 컴포넌트는 렉시컬 환경(Lexical Environment) 컴포넌트, 변수 환경 컴포넌트, 디스 바인딩(This Binding) 컴포넌트이다. 

렉시컬 환경 컴포넌트와 변수 환경 컴포넌트는 거의 독같다. 디스 바인딩 컴포넌트는 그 함수를 호출한 객체의 참조가 저장되는 곳이다. 이것이 가리키는 값이 곧 해당 실행 문맥의 this가 된다.

#### 렉시컬 환경 컴포넌트의 구성

실행 문맥의 구성 요소인 렉시컬 컴포넌트는 자바스크립트 엔진이 자바 스크립트 코드를 실행하기 위해 자원을 모아 둔 곳으로 구체적으로 함수 또는 블록의 유효 범위안에 있는 식별자와 그 결과값이 저장되는 곳이다. 자바스크립트 엔진은 해당 자바스크립트 코드의 유효 범위 안에 있는 식별자와 그 식별자가 가리키는 값을 키와 값의 쌍으로 바인드해서 렉시컬 환경 컴포넌트에 기록한다. 렉시컬 환경 컴포넌트는 환경 레코드와 외부 렉시컬 환경 참조 컴포넌트로 구성되어 있다. 

환경 레코드는 유효 범위 안에 포함된 식별자를 기록하고 실행하는 영역이다. 

외부 렉시컬 환경 참조에는 함수를 둘러싸고 있는 코드가 속한 렉시컬 환경 컴포넌트의 참조가 저장된다. 중첩된 함수 안에서 바깥 코드에 정의된 변수를 읽거나 써야 할 떄, 자바스크립트 엔진은 외부 렉시컬 환경 참조를 따라 한 단계씩 렉시컬 환경을 거슬러 올라가서 그 변수를 검색한다.

환경 레코드는 렉시컬 환경 안의 식별자와 그 식별자가 가리키는 값의 묶음이 실제로 저장되는 영역이다. 이 환경 레코드는 선언적 환경 레코드와 객체 환경 레코드로 구성되어 있으며 저장하는 값의 유형에 따라 쓰임새가 달라진다.

선언적 환경 레코드는 실제로 함수와 변수, catch 문의 식별자와 실행 결과가 저장되는 영역이다.

객체 환경 레코드는 실행 문맥 외부에 별도로 저장된 객체의 참조에서 데이터를 읽거나 쓴다.

#### 전역 환경과 전역 객체의 생성

자바스크립트 인터프리터는 시작하자마자 렉시컬 환경 타입의 전역 환경을 생성한다. 웹 브라우저에 내장된 자바스크립트 인터프리터는 새로운 웹 페이지를 읽어 들인 후에 전역 환경을 생성한다. 그리고 전역 객체를 생성한 다음 전역 환경의 객체 환경 레코드에 전역 객체의 참조를 대입한다.

### 클로저

클로저는 자바스크립트가 가진 기능으로, 이를 활용하면 변수를 은닉하여 지속성을 보장하는 등의 다양한 기능들을 구현할 수 있다. 

### 이름 공간

전연 유효 범위의 오염을 방지하기 위한 수단으로서 객체와 함수를 이름 공간으로 이용한다.

저역 변수와 전역 함수를 전역 객체에 선언하는 행위는 전역 유효 범위를 오염시킨다고 볼 수 있다. 전역 유효 범위가 오염되면 다음과 같은 상황에서 변수 이름과 함수 이름이 겹칠 수 있다.

- 라이브러리 파일을 여러 개 읽어 들여 사용할 때
- 규모가 큰 프로그램을 만들 떄
- 여러 사람이 한 프로그램을 만들 떄

전역 유효 범위 안에서 이름이 같은 변수나 함수를 선언하면 자바스크립트 엔진이 그 프로그램의 첫머리로 끌어올려서 변수 또는 함수를 단하나만 생성한다. 그러면 다른 목적으로 사용하는 코드가 같은 변수와 함수를 공유하게 되므로 올바르게 동작하지 않을 수 있다. 이러한 오류를 피하기 위해 오염을 최소화 하여야 한다. 

#### 객체를 이름 공간으로 활용하기

이름 공간이란 변수 이름과 함수 이름을 한곳에 모아 두어 이름 충돌을 미리 방지하고, 변수와 함수를 쉽게 가져다 쓸 수 있게 만든 메커니즘이다. 객체를 이름 공간으로 활용하려면 객체를 값으로 가지는 전역 변수를 하나 생성하고, 그 객체에 프로그램 전체에서 사용하는 모든 변수와 함수를 프로퍼티로 정의한다. 예를 들어 다음과 같은 방법으로 myApp이라는 전역 변수를 이름 공간으로 활용 할 수 있다.
```js
var myApp = myApp || {};
```

이렇게 작성해 두면 myApp이 이미 정의되어 있을 때는 그것을 사용하고 그렇지 않으면 빈 객체를 myApp에 할당한다. 이 객체에 전역 유효 범위에서 사용하고자 하는 모든 변수와 함수를 프로퍼티로 추가하면 된다.
```js
myApp.name = "Tom";
myApp.showName = function() {...};
```

이렇게 되면 myApp만이 사용자가 정의한 전역 변수가 되므로 전역 유효 범위의 오염을 최소화할 수 있다.
또한 myApp 객체 내에 새로운 객체를 추가함으로써 부분 이름 공간을 만들 수도 있다.

#### 함수를 이름 공간으로 활용하기

함수 안에서 선언된 변수의 유효 범위는 함수 내부이다. 따라서 그 변수를 함수 안에서는 읽거나 쓸 수 있지만 바깥에서는 읽거나 쓸 수 없다. 이 성질을 활용하면 함수를 이름 공간으로 활용할 수 있다.
```js
(function() {
    var x = "local x";
})();
console.log(x); // Uncaught ReferenceError
```
즉시 실행 함수 내부에서 선언한 변수인 x는 이 함수의 지역 변수이므로 전역 변수와 이름이 충돌하지 않는다. 따라서 일시적인 처리를 수행하고자 할 때 그 내용물을 즉시 실행 함수 안에 작성하면 전역 유효 공간을 오염시키지 않고 실행 할 수 있다.


