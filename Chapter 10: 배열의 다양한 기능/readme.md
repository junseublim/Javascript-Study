# 배열의 메서드

배열은 Array 타입 객체이며 Array.prototype의 프로퍼티를 상속받는다. Array.prototype에는 수많은 메서드가 정의되어있으며, 모든 배열은 이 메서드를 사용할 수 있다. 이들 메서드를 사용하면 직접 코드를 작성하지 ㅇ낳아도 다양한 배열을 처리할 수 있다.

## Array.prototype의 메서드 목록

### 수정 메서드

1. push : 배열 마지막에 하나 이상의 요소를 추가한다음 그 배열의 길이를 반환.
    - 만약 두 개 이상 요소를 추가하려면 쉼표로 구분
2. pop : 배열의 마지막 요소를 잘라내어 반환한다.
3. shift : 배열의 첫번째 요소를 제거한 후 모든 배열 요소를 왼쪽으로 이동시킨다. 반환값은 삭제된 요소의 값.
4. unshift: 배열 앞부분 요소를 한 개 이상 추가한 후 모든 배열 요소를 오른쪽으로 이동시킨다. 반환값은 그 배열의 길이.
    - 요소 두개 이상 시 쉼표로 구분
5. splice: 특정 인덱스의 베열 요소를 갈아 끼울 떄 사용. 요소를 끼워넣기만 할 수도 있고 삭제 할 수도 있다. 삭제된 요소는 배열로 만들어서 반환한다.
    - 첫 번째 인수 index: 배열의 수정 시작 위치
        - 첫 번째 인수만 넘기면 index 이후 모든 요소 삭제
    - 두 번째 인수 howmany: 배열에서 삭제할 요소의 개수
    - 세 번째 인수 : 배열에 삽입할 요소의 값을 쉼표로 구분해서 넘김.
    ```js
        var a= ["A", "B", "C", "D"];
        a.splice(1,2, "X", "Y", "Z"); // a = ["A","X","Y",""Z","D"]
                                      // 반환값 = ["B","C"]
    ```
6. sort : 배열안의 요소를 정렬한다. 인수로는 실제로 비교를 담당하는 함수의 참조를 넘기며 반환값은 정렬된 배열이다. 비교 함수를 넘기지 않으면 배열의 요소를 문자열로 변환한 다음에 사전순으로 정렬한다. 값이 undefined인 요소가 있다면 그 요소는 배열의 마지막에 위치시킨다.


### 접근자 메서드
 
수정 메서드와는 다르게 기존 배열은 수정하지 않고 새로운 배열을 반환한다.

 1. join : 배열의 모든 요소 값을 문자열로 바꾼후에 인수로 받은 문자로 연결해서 반환. 
 2. concat: 인수로 받은 값을 그 배열의 요소를 추가해서 새로운 배열을 생성한다. 받은 인수가 배열이면 펼친 후에 배열에 추가한다.
 3. slice : 배열의 일부 요소를 제거한 새로운 배열을 반환한다.   
 4. indexOf : 배열 안에서 인수로 지정한 값을 검색해서 가장 먼저 찾은 요소의 인덱스를 반환한다. 찾지 못했을 때는 -1을 반환. 
 5. lastIndexOF: indexOf와 동일하지만 뒤에서 순서대로 검색한다. 

 ### 반복 메서드

 배열의 모든 요소를 순회하며 특정한 작업을 수행하거나 특정 조건을 만족하는 요소를 가져올 때 사용.
 - 반복 메서드의 인수로 전달한 함수는 배열의 요소마다 호출된다. 이 때 반복하는 배열이 희소 배열이면 없는 요소에 대해서는 호출되지 않는다.
 - 반복 함수 대부분은 첫 번째 인수로 함수를 받으며 이 함수에는 다음 인수 세 개가 전달된다.
     - value : 현재 처리하고 있는 배열 요소의 값
     - index : 현재 처리하고 있는 배열 요소의 인덱스
     - array : 메서드가 적용되는 배열의 참조 
 - reduce, reduceRight 제외한 나머지는 두번째 인수를 지정할 수 있다. 이는 첫 번쨰 인수로 받은 함수 안의 this 값이며 생략할 수 있다.

1. forEach : 배열의 요소를 한번씩 순회.
2. map : 인수로 받은 함수의 배열의 요소별로 한번씩 실행하며, 마지막에는 그 함수가 반환한 값으로 새로운 배열을 생성한다. 
3. reduce : 배열의 첫번째 요소부터 마지막 요소까지의 합성곱 처리를 한다.
    - callback : 합성 곱을 하는 함수
        - prev : 이전 요소를 처리한 함수의 반환값, 또는 initial 값
        - value : 현재 처리하는 요소의 값
        - index : 현재 처리하는 배열 요소의 인덱스
        - array : 메서드를 적용 중인 배열의 참조
    - initial : callback이 처음 호출 되었을 떄의 첫 번째 인수의 값
        - 생략 시 첫번째 요소의 값으로 설정하고 두번째부터 처리

# 유사 배열 객체

배열은 아니지만 배열로 처리할 수 있는 객체를 유사 배열 객체라고 한다.

자바스크립트에서 Array 타입의 객체는 다음과 같은 성질이 있다.
1. 0 이상의 정수 값을 프로퍼티 이름으로 갖는다.
2. length 프로퍼티가 있으며, 요소를 추가하거나 삭제하면 length 프로퍼티 값이 바뀐다.
3. 프로토타입이 Array.prototype이므로 메서드를 상속받아 사용할 수 있다.

유사 배열 객체는 이중에서 1, 2번 성질을 가지는 객체이다.

예를 들어 다음은 유사 배열 객체이다.
 - 함수의 인수를 저장한 Arguments 객체
 - DOM의 document.getElementsByTagName 등이 반환하는 NodeList 객체

유사 배열 객체는 Array.prototype의 메서드를 사용할 수 없다. 그러나 배열로 참조하거나 대입할 수 있으며, for 문이나 for/in 문으로 처리할 수 있다.

Array.prototype의 메서드를 유사 배열 객체에서 사용하려면 call 메서드로 간접 호출하면 된다.

# ECMAScript 6의 배열과 새롭게 추가된 기능

##  비구조화 할당

배열의 비구조화 할당
1. 기본적인 사용법
```js
var [a,b] = [1,2]; // a = 1, b = 2
[a,b] = [2*a, 3*b]; // a = 2, b = 6
[a,b] = [b,a]; // a = 6, b = 2

[a,b,c] = [1,2]; // a = 1, b = 2, c = undefined
[a,b] = [1,2,3]; // a = 1, b = 2
[,a,,b] = [1,2,3,4] // a= 2, b= 4
```
2. 나머지 요소
```js
[a,b, ...rest] = [1,2,3,4] // a = 1, b = 2, rest =[3,4]
```
3. 요소의 기본값
```js
[a=0,b=1, c=2] = [1,2] // a = 1, b = 2, c = 2 
```

객체의 비구조화 할당
1. 기본적인 사용법
```js
var {a:x, b:y} = {a: 1, b: 2}; // a = 1, b = 2
{a: x, b: y} = {a: y, b: x}; // a = 2, b = 1
{a: x, b: y} = {a: 1. c: 2}; // a = 1, b = undefined
{a: x, b: y} = {a: 1, b: 2, c: 2}; // a= 1, b = 2
```

2. 프로퍼티의 기본값
```js
{a: x=1, b: y=2, c: z=3} = {a: 2, b: 4} // a = 2, b = 4, c = 3
```

3. 프로퍼티 이름 생략하기
```js
{a, b} = {a: 1, b: 2}; //a = 1, b = 2
{a = 1, b = 2, c = 3} =  {a: 2, b: 4} // a = 2, b = 4, c = 3
```

## 전개 연산자

전개 연산자는 반복 가능한 객체를 반환하는 표현식 앞에 표기하며, 이를 통해 반복 가능한 객체를 배열 리터럴 또는 함수의 인수 목록으로 펼칠 수 있다.
```js
[..."ABC"] // ["A", "B", "C"]
f(..."ABC") // f("A", "B", "C")
[1, ...[2,3,4]] // [1,2,3,4]
f(...[1,2,3]) // f(1,2,3)
```

## ArrayBufer와 형식화 배열(TypedArray)

ArrayBuffer, DataView, 형식화 배열은 연속된 데이터 영역을 조작하기 위해 만들어진 객체이다. 이들을 활용하면 배열과 이미지 데이터를 빠르게 읽고 쓸 수 있다.

### ArrayBuffer 생성자
ArrayBuffer 생성자는 메모리에 고정 길이를 가진 인접한 영역을 확보한다. 단 ArrayBuffer는 메모리에 영역을 확보하는 역할만 하며 버퍼를 조작하는 메서드는 제공하지 않는다. 버퍼를 조작하려면 형식화 배열 또는 DataView 객체를 사용해야 한다.
```js
var buffer = new ArrayBuffer(1024);
console.log(buffer.byteLength) // 1024

var copy = buffer.slice(3,6); 
//buffer 전체에서 3바이트부터 5바이트까지 일부분을 복사한 새로운 ArrayBuffer 객체가 생성되며 그 참조가 변수 copy에 저장된다.
```

### 형식화 배열

#### 형식화 배열 특징
- 요소의 개수는 제한적이다.
- 길이가 고정되어 있으며 요소 추가, 삭제가 불가능
- Array.prototype 메서드 사용 불가능. 단, TypedArray.prototype이 제공하는 메서드가 존재
- 모든 요소가 0으로 초기화

#### 형식화 배열의 생성

형식화 배열은 요소가 차지하는 비트에 따라 9종류로 구분할 수 있다. 형식화 배열을 생성하려면 생성자 함수에 배열의 길이를 인수로 전달한다.
```js
var a = new Int8Array(10);
console.log(a.length) // 10
console.log(a.BYTES_PER_ELEMENT) // 1
```
ArrayBuffer로 생성한 버퍼를 인수로 넘겨 생성할 수도 있다.
```js
var buffer = new ArrayBuffer(100);
var a = new Int16Array(buffer);
console.log(a.length) // 50 (100bytes / 2bytes)
```


## Map
Map 객체는 데이터를 수집하여 활용하기 위한 객체이다. 값의 고유한 식별 정보인 '키'와 갑스이 쌍을 Map 객체 안에 저장해서 사용한다. 

- 일반 객체와는 다르게 Map 객체는 키 타입에 제한이 없다.
- 해시 테이블을 활용하기 때문에 데이터 검색 속도가 빠르다.
- Map 객체는 반복 가능하며, 키와 값으로 구성된 배열을 반화한다.
- Map 객체는 데이터 개수를 size 프로퍼티로 구할 수 있다.

### 생성
```js
var map = new Map(); // Map {}

var map2 = new Map([["Tom", 20], ["Huck", 100]]) 
// Map {"Tom" => 20, "Huck" => 100}
```

### 데이터 추가
set(key, value) 메서드로 추가. key 존재시 덮어쓴다.
```js
var zip = new Map();
zip.set("Tom", 120);
```

### 값읽기
get(key) 메서드로 읽는다.
```js
zip.get("Tom"); // 120
```

### 데이터 존재 확인
has(key) 메서드로 찾는다.
```js
zip.has("Tom"); //true
```

### 데이터 삭제
delete(key) 메서드로 삭제한다.
```js
zip.delete("Tom");
```
clear() 메서드로 모든 데이터를 삭제 할 수 있다.

### 모든 데이터 열거
1. 모든 키의 열거
keys() 메서드는 키 값을 가진 이터레이터를 반환한다.
2. 모든 값의 열거
values() 메서드는 데이터 값을 가진 이터레이터를 반환한다.
3. 모든 키, 값의 열거
entries() 메서드는 키와 데이터 값을 가진 이터레이터를 반환한다.
```js
var iter = zip.keys();
var iter = zip.values();
var iter = zip.entries();
```

## Set 

중복되지 않는 유일한 데이터를 수집하여 활용하기 위한 객체.

### 생성
```js
var set = new Set(); // Set {}

var set2 = new Set(["Tom", "Huck"]) 
```

### 동일성의 정의
Set 객체에서 값 동일성은 일치 연산자와 차이가 난다. NaN은 NaN이랑 같으며 +0와 -0이 같다.

### 데이터 추가
add(value) 메서드로 추가.
```js
var set = new Set();
set.add("Tom");
```


### 데이터 존재 확인
has(value) 메서드로 찾는다.
```js
set.has("Tom"); //true
```

### 데이터 삭제
delete(value) 메서드로 삭제한다.
```js
set.delete("Tom");
```
clear() 메서드로 모든 데이터를 삭제 할 수 있다.

### 모든 데이터 열거
1. 모든 값의 열거
keys(), values() 메서드는 데이터 값을 가진 이터레이터를 반환한다.
3. 모든 키, 값의 열거
entries() 메서드는 [데이터, 데이터] 값을 가진 이터레이터를 반환한다. 이는 Map의 entries 메서드와 출력 형식을 통일하기 위해서이다.
```js
var iter = zip.keys();
var iter = zip.values();
var iter = zip.entries();
```